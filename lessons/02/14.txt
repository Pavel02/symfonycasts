Autowiring Aliases

Библиотека из части 13.txt  не заработала, потому что
 подходы написания кода на Symfony 4  отличаются от предыдущей версии Symfony 3.

 В Symfony 3  Сервисы задавались как  public , это означало, что из экшенов контроллеров их можно было использовать через
  шорткад метод  $this->get()  получая сервис по его идентификатору.
  Как пример:
            class DefaultController extends Controller
            {
                public function indexAction()
                {
                    $slack = $this->get('nexy_slack.client');
            ..........

 В Symfony 4  большинство сервисов   private   и к ним обратиться  $this->get()   не удастся.  В 4 версии новая философия.
   это можно увидеть   в конфиг файле    /config/services.yaml
            services:
                # default configuration for services in *this* file
                _defaults:
                    autowire: true      # Automatically injects dependencies in your services.
                    autoconfigure: true # Automatically registers your services as commands, event subscribers, etc.
                    public: false       # Allows optimizing the container by removing unused services; this also means
            ...........
 И так как Сервисы приватные то не    $this->get()  мы должны получать Сервисы через использование  "внедрение зависимостей"   "dependency injection".


***Fetching a Service by id***
  Выполним команду
                php bin/console debug:container nexy_slack.client
    получим следующий вывод
            Information for Service "nexy_slack.client"
            ===========================================

             ---------------- -------------------
              Option           Value
             ---------------- -------------------
              Service ID       nexy_slack.client
              Class            Nexy\Slack\Client
              Tags             -
              Public           yes
              Synthetic        no
              Lazy             no
              Shared           yes
              Abstract         no
              Autowired        no
              Autoconfigured   no
             ---------------- -------------------

  Класс для этого Сервиса   Nexy\Slack\Client
    но ранее, когда выполняли     debug:autowiring    то такого  тайп-хинт там не было.

  Ради эксперимента можем попробавать использовать этот тайп-хинт для получения сервиса, как делали ранее с   MarkdownHelper
                use Nexy\Slack\Client;
                ........
                public function show($slug, MarkdownHelper $markdownHelper, Client $slack)
                {
                    if ($slug === 'khaaaaaan') {
                        $message = $slack->createMessage()
                            ->from('Khan')
                            ->withIcon(':ghost:')
                            ->setText('Ah, Kirk, my old friend...');
                        $slack->sendMessage($message);
                    }
                ..................
     и попробуем в адресную строку передать этот  slug (обратиться по адресу  http://127.0.0.1:8000/news/khaaaaaan  ), то будет ошибка
                        Cannot autowire argument $slack of "App\Controller\ArticleController::show()": it references class "Nexy\Slack\Client" but no such service exists.
                        You should maybe alias this class to the existing "nexy_slack.client" service.
  для эксперимента попробуем в конструктор, также не отработает
                        public function __construct(bool $isDebug, Client $slack)
                        {

  У нас отсутствует конфигурация, сообщающая контейнеру, какой сервис передавать по указанному  тайп-хинту.
  В конфиг файл   /config/services.yaml   добавим
                                # setup special, global autowiring rules
                                bind:
                                    $markdownLogger: '@monolog.logger.markdown'
                                    $isDebug: '%kernel.debug%'
                                    Nexy\Slack\Client: '@nexy_slack.client'
    В этом блоке настроек можем сделать связывание
       - к имени переменной.
       - к интерфейсу

Теперь если в браузере перезагрузить     http://127.0.0.1:8000/news/khaaaaaan    то заработало.


*** Autowiring Aliases ***
 Сейчас сделано bind по default, но можем этот сервис поместить в корень файла, как  root  Сервис
                    services:
                        # default configuration for services in *this* file
                        _defaults:
                            autowire: true      # Automatically injects dependencies in your services.
                            autoconfigure: true # Automatically registers your services as commands, event subscribers, etc.
                            public: false       # Allows optimizing the container by removing unused services; this also means
                                                # fetching services directly from the container via $container->get() won't work.
                                                # The best practice is to be explicit about your dependencies anyway.
                            # setup special, global autowiring rules
                            bind:
                                $markdownLogger: '@monolog.logger.markdown'
                                $isDebug: '%kernel.debug%'

                        # custom aliases for autowiring
                        Nexy\Slack\Client: '@nexy_slack.client'

 Будет работать в обоих случаях, но поступая как в варианте 2 мы увидим этот сервис в общем доступном списке, воспользовавшись командой:
            php bin/console debug:autowiring
  мы увидим фрагмент выдачи
                          Michelf\MarkdownInterface
                              alias to markdown.parser.light
                          Nexy\Slack\Client
                              alias to nexy_slack.client
                          Psr\Cache\CacheItemPoolInterface
                              alias to cache.app
   когда он просто под   bind , его в этом списке не будет.


*** About Autowiring Logic ***
Прописав   Nexy\Slack\Client: '@nexy_slack.client'  непосредственно под  services:   мы в контейнере создали новый Сервис с id = nexy_slack.client
Но это ненастоящий сервис, а всего лишь алиас для его получения.

Контейнер ищет Сервис, чей   id  совпадает с  Тайп-хинтом.

Каждый класс в  /src/    автоматически регистрируется как Сервис и получает   id  который будет совпадать с именем класса.



