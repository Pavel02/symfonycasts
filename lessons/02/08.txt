Creating Services!

В контролере класса  ArticleController.php   в его методе
        public function show($slug, MarkdownInterface $markdown, AdapterInterface $cache)
          имеет смысл перенести логигу cache  и   markdown   в отдельный файл.
 Для этого есть 3 причины:
   1. код этого метода становистя большим и трудночитаемым.
   2. нельзя повторно использовать этот код, потому что он вшит в этом методе.
   3. этот код не может быть покрыт тестами.


Воспользуемся самым старым трюком в программировании: Если хотим повторно использовать код, то выносите его в отдельную функцию.


Создадим новый файл  src/Service/MarkdownHelper.php
            <?php

            namespace App\Service;


            class MarkdownHelper
            {
                public function parse(string $source): string
                {
                    $item = $cache->getItem('markdown_' . md5($source));
                    if (!$item->isHit()) {
                        $item->set($markdown->transform($source));
                        $cache->save($item);
                    }

                    return $item->get();
                }
            }

Этот метод в классе пока что работать не будет, но это уже новый Сервис.
 Сервис - просто Класс, который работает.
 если выполнить  bin/console debug:autowiring    ,  то в выводе этой команды уже будет.
                  App\Service\MarkdownHelper
 т.е. этот Сервис уже находится в контейнере.
 т.е. автовайринг нового сервиса произошел автоматически.

 Если нам нужны некоторые Сервисы можем просто их передать переменными в метод.
                        public function parse(string $source, AdapterInterface $cache, MarkdownInterface $markdown): string

Если сейчас обновить браузер, также не отработает будет ошибка:
        Too few arguments to function App\Service\MarkdownHelper::parse(), 1 passed in /var/www/my-repo/the_spacebar/src/Controller/ArticleController.php on line 59 and exactly 3 expected

И действительно в ArticleController.php метод вызывается как:
        $articleContent = $markdownHelper->parse($articleContent);


Автовайринг, корректно работает с Экшенами в контроллерах, потому что для них
 существует единственный уникальный раз, когда Симфони вызывает эти методы.
Но все решается просто в Экшн show()  добавим
                    $articleContent = $markdownHelper->parse(
                        $articleContent,
                        $cache,
                        $markdown
                    );

Код конечно начнет работать, а логику работу с Кэшом и Маркдаун убрали в Хелпер, добившись цели.
 Но есть более верный способ     Proper Dependency Injection

Когда есть Сервис, зависящий от других сервисов (в нашем случае зависимость от $cache и $markdown),
  то вместо передачи таких Сервисов в качестве аргументов в отдельный метод, то можно задавать их в Конструкторе.

Создадим конструктор класса MarkdownHelper, и в него будут передаваться и устанавливаться зависимости.
                    class MarkdownHelper
                    {
                        private $cache;
                        private $markdown;

                        public function __construct(AdapterInterface $cache, MarkdownInterface $markdown)
                        {
                            $this->cache = $cache;
                            $this->markdown = $markdown;
                        }
                    ......................
Теперь с точки зрения класса неважно кто будет использовать класс, но ему придется передать используемые зависимости.

Одно из преимуществ устанавливать зависимости через конструктор, это дальнейшая возможность в методы
  передавать аргументами только вещи специфические именно для этого конкретного метода.
   (как в нашем примере метод      parse($content)     принимает контент.

Происходит матрешка MarkdownHelper явно не создается (я имею ввиду, что в коде нет new) и также обстоит дело с объектами
 Сервисов, которые передаются в его конструктор.











